/**
 * @fileoverview Firestore Security Rules for Tabdeel Platform
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and items.
 * SwapRequests are secured based on the participants (requester and target owner).
 * Messages are secured within their parent SwapRequest.
 * Categories are publicly readable.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, where userId matches the Firebase Auth UID.
 * - /items/{itemId}: Items available for swap. Each item has an ownerId field.
 * - /swapRequests/{swapRequestId}: Swap requests between users.
 * - /swapRequests/{swapRequestId}/messages/{messageId}: Messages within a swap request.
 * - /categories/{categoryId}: Item categories (publicly readable).
 *
 * Key Security Decisions:
 * - Users can only read/write their own profile data.
 * - Items can be created by any authenticated user, but only the owner can update/delete them.
 * - SwapRequests can be created by any user, and read/written to by involved users only.
 * - Categories are publicly readable.
 *
 * Denormalization for Authorization:
 * The 'Item' entity denormalizes the 'ownerId' to simplify item ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) - If the user's UID matches the userId in the path.
     * @allow (get, list) - If the user's UID matches the userId in the path.
     * @allow (update, delete) - If the user's UID matches the userId in the path and the document exists.
     * @deny (create) - If the user is not signed in.
     * @deny (update, delete) - If the user is not signed in or does not own the profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update, delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to item documents.
     * @path /items/{itemId}
     * @allow (create) - If the user is signed in and sets ownerId to their UID.
     * @allow (get, list) - Public read access for all items.
     * @allow (update, delete) - If the user is signed in and owns the item.
     * @deny (update, delete) - If the user is not signed in or does not own the item.
     * @principle Enforces document ownership for item updates and deletes; allows public reads.
     */
    match /items/{itemId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return isSignedIn() && request.auth.uid == resource.data.ownerId;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Controls access to swap request documents.
     * @path /swapRequests/{swapRequestId}
     * @allow (create) - If the user is signed in.
     * @allow (get, list) - If the user is either the requester or the target owner.
     * @allow (update, delete) - If the user is either the requester or the target owner and the document exists.
     * @deny (update, delete) - If the user is not signed in or not a participant.
     * @principle Enforces access control based on swap request participation.
     */
    match /swapRequests/{swapRequestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn() && (resource.data.targetOwnerId == request.auth.uid || resource.data.requesterId == request.auth.uid);
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn() && (resource.data.targetOwnerId == request.auth.uid || resource.data.requesterId == request.auth.uid);
    }

    /**
     * @description Controls access to message documents within a swap request.
     * @path /swapRequests/{swapRequestId}/messages/{messageId}
     * @allow (create) - If the user is signed in and a participant in the swap request.
     * @allow (get, list) - If the user is a participant in the swap request.
     * @allow (update, delete) - Denied. Messages should not be updated or deleted.
     * @deny (update, delete) - Always.
     * @principle Enforces access control based on swap request participation for messages.
     */
    match /swapRequests/{swapRequestId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isSwapRequestParticipant(swapRequestId) {
        return isSignedIn() && (get(/databases/$(database)/documents/swapRequests/$(swapRequestId)).data.targetOwnerId == request.auth.uid
            || get(/databases/$(database)/documents/swapRequests/$(swapRequestId)).data.requesterId == request.auth.uid);
      }

      allow get, list: if isSwapRequestParticipant(swapRequestId);
      allow create: if isSignedIn() && isSwapRequestParticipant(swapRequestId);
      allow update, delete: if false;
    }

    /**
     * @description Controls access to category documents.
     * @path /categories/{categoryId}
     * @allow (get, list) - Public read access for all categories.
     * @allow (create, update, delete) - Denied. Categories should only be managed via the console.
     * @deny (create, update, delete) - Always.
     * @principle Allows public reads for categories, restricts writes.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}