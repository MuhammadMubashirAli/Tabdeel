/**
 * @fileoverview Firestore Security Rules for the Tabdeel platform.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data ownership and prevents unauthorized access.
 * All user-specific data is secured under the /users/{userId} path and is only accessible to the authenticated user with a matching UID.
 * Top-level collections like 'items' and 'swapRequests' are secured to prevent unauthorized creation, modification, or deletion.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Access is restricted to the owning user.
 * - /items/{itemId}: Stores items for barter. Publicly readable, but write access is restricted to the owner (creator).
 * - /swapRequests/{swapRequestId}: Stores swap requests. Access is restricted to the involved users (requester and target).
 * - /swapRequests/{swapRequestId}/messages/{messageId}: Stores messages for a specific swap request. Access is restricted to the involved users.
 * - /categories/{categoryId}: Stores item categories. Publicly readable. Write operations are not explicitly secured and require further review.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data under /users/{userId}.
 * - Items are publicly readable to facilitate browsing but can only be created, updated, or deleted by their owner.
 * - Swap requests and messages are restricted to the users involved in the specific swap.
 * - The rules do not include validation for all fields. It is crucial to implement data validation in the client or server-side code to ensure data integrity.
 *
 * Denormalization for Authorization:
 * - Items: The `ownerId` field is used to enforce ownership.
 * - SwapRequests: The `targetOwnerId` and `requesterId` fields are used to determine the involved users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read and write their own data.
     * @path /users/{userId}
     * @allow (create, update, get, delete) - Authenticated user with matching UID creates/modifies their own profile.
     * @allow (list) - Authenticated user lists their own profile (unlikely, but included for completeness).
     * @deny (create, update, get, delete, list) - Any other user attempts to access another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure items for barter. Items are publicly readable, but only the owner can create, update, or delete them.
     * @path /items/{itemId}
     * @allow (get, list) - Any user can view the item.
     * @allow (create) - Authenticated user creates a new item with their UID as the ownerId.
     * @allow (update, delete) - Authenticated user with matching UID modifies/deletes their own item.
     * @deny (create, update, delete) - Any other user attempts to access or modify another user's item.
     * @principle Public read access with owner-only writes.
     */
    match /items/{itemId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.ownerId;
      }

      function isCreatingOwner() {
        return request.auth.uid == request.resource.data.ownerId;
      }

      function isExistingOwner() {
        return isOwner() && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isCreatingOwner();
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secure swap requests. Only the involved users (requester or target) can access the swap request.
     * @path /swapRequests/{swapRequestId}
     * @allow (get) - Requester or target user views the swap request.
     * @allow (list) - Requester or target user lists swap requests they are involved in.
     * @allow (create) - Authenticated user creates a swap request.
     * @allow (update) - Requester or target user updates the swap request.
     * @allow (delete) - No one can delete a swap request
     * @deny (get, list, create, update, delete) - Any other user attempts to access the swap request.
     * @principle Shared access between collaborators (requester and target).
     */
    match /swapRequests/{swapRequestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isTargetOwner() {
        return request.auth.uid == resource.data.targetOwnerId;
      }

      function isRequester() {
        return request.auth.uid == resource.data.requesterId;
      }

      function isExistingTargetOwner() {
        return isTargetOwner() && resource != null;
      }

      function isExistingRequester() {
        return isRequester() && resource != null;
      }

      function isCreating() {
        return request.auth.uid == request.resource.data.requesterId;
      }


      allow get: if isTargetOwner() || isRequester();
      allow list: if isTargetOwner() || isRequester();
      allow create: if isSignedIn() && isCreating();
      allow update: if isExistingTargetOwner() || isExistingRequester();
      allow delete: if false;
    }

    /**
     * @description Secure messages within a swap request. Only the involved users (requester or target) can access the messages.
     * @path /swapRequests/{swapRequestId}/messages/{messageId}
     * @allow (get) - Requester or target user views the message.
     * @allow (list) - Requester or target user lists messages they are involved in.
     * @allow (create) - Authenticated user creates a message in a swap request they are involved in.
     * @allow (update) - Never allow update for messages.
     * @allow (delete) - Never allow delete for messages.
     * @deny (get, list, create, update, delete) - Any other user attempts to access the messages.
     * @principle Shared access between collaborators (requester and target), inherited from the parent document.
     */
    match /swapRequests/{swapRequestId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isTargetOwner(swapRequestId) {
           return get(/databases/$(database)/documents/swapRequests/$(swapRequestId)).data.targetOwnerId == request.auth.uid;
      }

      function isRequester(swapRequestId) {
          return get(/databases/$(database)/documents/swapRequests/$(swapRequestId)).data.requesterId == request.auth.uid;
      }

        function isCreating(swapRequestId) {
           return get(/databases/$(database)/documents/swapRequests/$(swapRequestId)).data.requesterId == request.auth.uid || get(/databases/$(database)/documents/swapRequests/$(swapRequestId)).data.targetOwnerId == request.auth.uid;
      }

      allow get: if isTargetOwner(swapRequestId) || isRequester(swapRequestId);
      allow list: if isTargetOwner(swapRequestId) || isRequester(swapRequestId);
      allow create: if isSignedIn() && isCreating(swapRequestId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure item categories. Categories are publicly readable, but write operations are not explicitly secured and require further review.
     * @path /categories/{categoryId}
     * @allow (get, list) - Any user can view the categories.
     * @allow (create, update, delete) - No writes are explicitly allowed
     * @principle Public read access, but write access needs further review and restrictions.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add more secure write access based on roles.
    }
  }
}